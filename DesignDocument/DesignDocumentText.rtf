{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\fnil\fcharset128 OpenSymbol;}{\f2\fnil\fcharset0 Courier New;}{\f3\froman\fprq2\fcharset128 Times New Roman;}{\f4\fmodern\fprq1\fcharset128 Courier New;}{\f5\fnil\fcharset0 Times New Roman;}{\f6\fswiss\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\sa200\sl276\slmult1\lang9\kerning1\f0\fs22 Team Waugh\lang1033\fs24\par
\lang9\fs22 Tanks_Game_RW\lang1033\fs24\par
\lang9\fs22 Software Design Document\lang1033\fs24\par
\lang9\fs22 Names: Riley Waugh\lang1033\fs24\par
\lang9\fs22 Date of Creation: 9/2/2015\lang1033\fs24\par
\par
\lang9\ul\b\fs22 1. Intro\lang1033\ulnone\b0\fs24\par
\par
\lang9\fs22\tab\b 1.1 Purpose\lang1033\b0\fs24\par
\lang9\fs22\tab This design document will describe the workings and the process of creation of a \tab tanks \tab game.\lang1033\fs24\par
\lang9\fs22\tab\lang1033\fs24\par
\lang9\fs22\tab\b 1.2 Scope\lang1033\b0\fs24\par
\lang9\b\fs22\tab\b0 The sowtware will be a 2-d tanks game. This means that the player will control a \tab tanks, \tab navigate a mazelike map, and shoot bullets at other tanks. A map \tab creator/editor will \tab accompany the game.\lang1033\fs24\par
\lang9\fs22\tab\lang1033\fs24\par
\lang9\fs22\tab\b 1.3 Overview\lang1033\b0\fs24\par
\lang9\fs22\tab In this design doc, the game overview and architecture will be explained. this \tab document will also go over the data design and component design and human \tab interface design and requirements.\lang1033\fs24\par
\par
\lang9\fs22\tab\b 1.4 Reference Material\lang1033\b0\fs24\par
\lang9\fs22\tab The game will be reminiscent of "Tank Trouble" ({\field{\*\fldinst{HYPERLINK "https://www.tanktrouble.com/"}}{\fldrslt{\ul\cf1 https://www.tanktrouble.com/}}}\lang1033\f0\fs24 )\par
\par
\lang9\fs22\tab\b 1.5 Definitions and Acronyms\lang1033\b0\fs24\par
\lang9\fs22\tab "TGRW"refers to the software\lang1033\fs24\par
\par
\lang9\ul\b\fs22 2. System Overview\lang1033\ulnone\b0\fs24\par
\lang9\fs22\tab The game will be  a 2-d, top-down shooter game for strictly entertainment purposes. THe player will maneuver a tank through a labyrinthine map  in order to collect powerups or shoot the opponent. Upgrades will significantly increase the power of a tank. Reaction time and accuracy and experience will be key to winning a round. Whenever a player wins a round by shooting another player, the winning player will be awarded 1 point. A player wins the game by gaining a specified amount of points. Players will use the keyboard for controls.\lang1033\fs24\par
\lang9\fs22\tab A map editor will accompany the game.  A creator will be able to add walls, player spawn locations, and upgrade spawn loactions. The creator will then be able to save the map, and later load the map in the game.\lang1033\fs24\par
\par
\lang9\ul\b\fs22 3. System Architecture\lang1033\ulnone\b0\fs24\par
\lang9\fs22\tab\lang1033\fs24\par
\pard\nowidctlpar\fi-360\li1080\sa200\sl276\slmult1\tx1080\lang1023\b\fs22 3.1\tab\lang9 Architectural Design\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\b\fs22\tab\b0 see DesignDocumentVisuals.png in the DesignDocument folder.\lang1033\fs24\par
\par
\pard\nowidctlpar\fi-360\li1080\sa200\sl276\slmult1\tx1080\kerning0\b 3.2\tab\lang9\kerning1\fs22 Architectural Description\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\b\fs22\tab\b0 The player will transition from state to state using buttons, a type of menuEntity. Maps \tab created in the map editor will be saved as a text file, ready to be loaded for further use. \tab Maps will be saved and loaded based on deciphering strings. Guns will be created in a \tab text document, too. The player also specifies the \tab win condition, and when that win \tab condition is met in the Game class, the game transitions \tab to the EndGameMenu. \tab Transistioning will be a matter of disabling one state and enabling another.\lang1033\fs24\par
\lang9\fs22\tab\lang1033\fs24\par
\pard\nowidctlpar\fi-360\li1080\sa200\sl276\slmult1\tx1080\kerning0\b 3.3\tab\lang9\kerning1\fs22 Design Rationale\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\fs22\tab I picked a state-by-state architecture because it fits the desired function of swapping \tab between menus, engineering the game before you play it.\lang1033\fs24\par
\par
\par
\par
\par
\par
\pard\nowidctlpar\fi-360\li360\sa200\sl276\slmult1\tx360\kerning0\b 4.\tab\lang9\kerning1\ul\fs22 Data Design\lang1033\ulnone\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\fs22\tab\lang1033\fs24\par
\pard\nowidctlpar\fi-360\li1080\sa200\sl276\slmult1\tx1080\kerning0\b 4.1\tab\lang9\kerning1\fs22 Data Description\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\fs22\tab The data will be stored in vectors or as strings in text files\lang1033\fs24\par
\par
\pard\nowidctlpar\fi-360\li1080\sa200\sl276\slmult1\tx1080\kerning0\b 4.2\tab\lang9\kerning1\fs22 Data Dictionary\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\fs22\tab\tab Data:\lang1033\fs24\par
\pard\nowidctlpar\fi-360\li1440\sa200\sl276\slmult1\tx1440\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Collision\ulnone : determing collision between Collidables will be done in the Game class update cycle and will only be used in that class.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Weapons\ulnone : guns will be stored as  text documents.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 maps\ulnone : maps will be stored as text documents.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 mouse data\ulnone : mouse data will be collected in the base app and sent up a chain of updates.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 sprites and textures\ulnone : The resource manager will load all images from a directory and will be accessable from every class.\lang1033\fs24\par
\pard\nowidctlpar\li1440\sa200\sl276\slmult1\par
\lang9\fs22 Objects:\lang1033\fs24\par
\pard\nowidctlpar\fi-360\li1440\sa200\sl276\slmult1\tx1440\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 BasicButton\ulnone : A child of MenuEntity. Based on mouse data, the button will either be idle, hovered, held down, being clicked, idle and clicked, hovered and clicked, held down and clicked, or being unclicked. The button will return this information as an enum.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 BasicBullet\ulnone : The bullet of the BasicGun; bounces off walls.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 BasicGun\ulnone : The default gun.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Bullet\ulnone : A child of collidable. Bullets move around the screen.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Collidable\ulnone : Two collidables are the only things that can collide.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 CollidableManager\ulnone : A vector of all collidables that can provide pointers to collidables and can check collision.\lang1033\fs24\par
\pard\nowidctlpar\li1440\sa200\sl276\slmult1\par
\pard\nowidctlpar\fi-360\li1440\sa200\sl276\slmult1\tx1440\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 CollisionBoxVector\ulnone : A member of Collidable; Each Collidable has a vector of vectors of points to determine collision.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 ControlSet\ulnone : A set of keys.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 EndGameMenu\ulnone : One of the main states of the software. When the game is won, the EndGameMenu appears.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Game\ulnone : A Game is a map, a determiner of tags, and a broad updater. One of the main states of the software.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 GeneralMap\ulnone : Parent of GMap and MEMap; contains a vector of rectangles.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 GMap\ulnone : aka game map, Gmap is a child of GeneralMap and Collidable\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Gun\ulnone : A weapon; determines things like spread, initial velocity of a bullet, etc.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MainMenu\ulnone : One of the main states of the software. From the MainMenu, the player can access most parts of the software.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MapEditor\ulnone : a main state of software. It allows the player to create maps they will play on in the Game class.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MEMap\ulnone : A child of GeneralMap and has a grid of tiles and 2 collisionBoxVectors.\par
\lang1033\kerning0\f1\fs24\'81\'45\f0\tab\ul MEEntity\ulnone : a Wall, a PlayerSpawn, or an UpgradeSapawn. Every MEEntity can be dragged an dropped and has a source area.\par
\f1\'81\'45\f0\tab\ul MEEntityManager\ulnone : Manages the functionality of the map editor along with MenuManager.\kerning1\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Menu\ulnone : A menu is a set of menuEntities.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MenuBackground\ulnone : One child of MenuEntity. It is essentially just a texture with a position.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MenuEnitity\ulnone : Any type of button, text, image, etc.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MenuManager\ulnone : A set of Menus for cases like the MainMenu, where there may be sound menus, option menus, etc.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MinigunBullet\ulnone : A child of Bullet; bounces off walls.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MinigunGun\ulnone : A child of Gun; faster firing rate and more spread than Basicgun\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 MinigunPU\ulnone : A child of Powerup; can upgrade and upgradable \lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Player\ulnone : A tank. Players can move, shoot, win the game, etc.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 PlayerManager\ulnone : Keeps a vector of all players. Can also provide pointers to Players.\par
\lang1033\kerning0\f1\fs24\'81\'45\f0\tab\ul PlayerSpawn\ulnone : A child of MEEntity; when loaded, will be an area to spawn a Player.\kerning1\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Powerup\ulnone : A child of Collidable; can  ugrade a Player's stats\lang1033\fs24 .\par
\kerning0\f1\'81\'45\f0\tab\ul PowerupSpawn\ulnone : A child of MEEntity; when loaded, will be an area to spawn powerups.\kerning1\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 ResourceManager\ulnone : A set of textures and fonts that can load all files of a type (e.g. .ttf, .jpeg, .png) from a given directory. It also can provide pointers to textures and fonts.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 Slider\ulnone : A child of MenuEntity; it contains a knob and a base, and the position of the knob on the base affects something, like brightness or music volume.\lang1033\fs24\par
\kerning0\f1\'81\'45\tab\lang9\kerning1\ul\f0\fs22 TextBox\ulnone : A child of MenuEntity; simply centered text.\par
\lang1033\kerning0\f1\fs24\'81\'45\f0  \tab\ul Wall\ulnone : A child of MEEntity; one of the things that can be placed on a map and will become non-transversable terrain when loaded.\kerning1\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\par
\tab\b 5. Component Design\b0\par
\lang9\fs22\tab The MainMenu is the starting state of the software. The player will uses buttons to \tab navigate to other menus and states. It will look something like this:\lang1033\fs24\par
\lang9\f2\fs22\tab udpate\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\lang9\fs22\tab\tab update menu entities;\lang1033\fs24\par
\lang9\fs22\tab\tab if menu/state button was activated,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab go to menu/state;\lang1033\fs24\par
\lang9\fs22\tab\}\lang1033\f0\fs24\par
\lang9\f3\fs22\tab\lang1033\f0\fs24\par
\lang9\f3\fs22\tab The EndGameMenu will operate in a similar way.\lang1033\f0\fs24\par
\lang9\f3\fs22\tab The Game update loop does many things and will look something like this:\lang1033\f0\fs24\par
\lang9\f2\fs22\tab update\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\lang9\fs22\tab\tab if 'P' button is pressed,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab pause menu activates;\lang1033\fs24\par
\lang9\fs22\tab\tab\lang1033\fs24\par
\lang9\fs22\tab\tab Update CollidableManager (all collidables)\lang1033\fs24\par
\lang9\fs22\tab\tab get and interpret all collisions\lang1033\fs24\par
\par
\par
\lang9\fs22\tab\tab if wincon is met or 'ESC' is pressed, \lang1033\fs24\par
\lang9\fs22\tab\tab\tab move to EndGameScreen;\lang1033\fs24\par
\par
\lang9\fs22\tab\}\lang1033\f0\fs24\par
\lang9\fs22\tab The Game update loop looks simple, but updating the collidablemanager is deceptively\lang1033\fs24\par
\lang9\fs22\tab  complicated. It will look someting like this\lang1033\fs24\par
\lang9\f2\fs22\tab /*for CollidableManager*/ update\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\lang9\fs22\tab\tab for all collidables, increment movement.\lang1033\fs24\par
\lang9\fs22\tab\tab clear vector that holds all collisions;\lang1033\fs24\par
\lang9\fs22\tab\tab fill collision vector();\lang1033\fs24\par
\lang9\fs22\tab\tab process collision vector();\lang1033\fs24\par
\lang9\fs22\tab\}\lang1033\f0\fs24\par
\lang9\f3\fs22\tab Again, this looks simple. Fill collision vector is more interesting:\lang1033\f0\fs24\par
\lang9\f3\fs22\tab\f2 Fill Collision Vector\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\pard\nowidctlpar\li-720\sa200\sl276\slmult1\lang9\fs22\tab\tab\tab for each permutation of two vectors, which \tab\tab\tab\tab\tab separates diffent types of \tab collidables,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab check if each element in one collides with\tab\tab\tab\tab\tab any element in the other, if so,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab\tab record element k of vector j colliding \tab\tab\tab\tab\tab with element l of vector m and put it \tab\tab\tab\tab\tab\tab into collision vector; \lang1033\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\fs22\tab\}\lang1033\f0\fs24\par
\par
\par
\par
\par
\lang9\f4\fs22\tab\f3 checking collision goes like this:\lang1033\f0\fs24\par
\lang9\f3\fs22\tab\f2 Collide(collidable a, collidable b)\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\lang9\fs22\tab\tab for each permutation of 1 of a's vectors of vectors \tab\tab of points and 1 of b's,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab for each of a's points x in that vector\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab check if x is inside b's vector of points, \tab\tab\tab\tab if so,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab\tab a collides with b, break;\lang1033\fs24\par
\par
\lang9\fs22\tab\}\lang1033\fs24\par
\lang9\fs22\tab checking if a point is inside a vector of points is annoying:\lang1033\fs24\par
\lang9\fs22\tab checkAinVecB\lang1033\fs24\par
\lang9\fs22\tab\{\lang1033\fs24\par
\lang9\fs22\tab\tab draw lines from each point bi in b;\lang1033\fs24\par
\lang9\fs22\tab\tab sum the angle <(bi,A,b((i+1)/b.size())) for all \tab\tab\tab i<b.size();\lang1033\fs24\par
\lang9\fs22\tab\tab if the sum == 2pi, it's inside\lang1033\fs24\par
\lang9\fs22\tab\}\lang1033\fs24\par
\lang9\fs22\tab finding the angle between vector u and v goes like this:\lang1033\fs24\par
\lang9\fs22\tab cos(angle between u and v) = (u DOT_PRODUCT v)/(||u|| ||v||)\lang1033\fs24\par
\par
\par
\par
\par
\par
\lang9\fs22\tab process collision vector goes like this:\lang1033\fs24\par
\lang9\fs22\tab process collision vector\lang1033\fs24\par
\lang9\fs22\tab\{\tab\lang1033\fs24\par
\lang9\fs22\tab\tab for every collision found, unincrement the movement of \tab\tab the collidables involved, but only once for each \tab\tab\tab collidable;\lang1033\fs24\par
\lang9\fs22\tab\tab if a Player hit a Powerup,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab powerup.affect(Player); // different for each \tab\tab\tab\tab\tab\tab\tab   // powerup\lang1033\fs24\par
\lang9\fs22\tab\tab\tab powerup disappears;\lang1033\fs24\par
\par
\lang9\fs22\tab\tab if a Player hit a bullet,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab player.health -= bullet.power;\lang1033\fs24\par
\par
\lang9\fs22\tab\tab if a bullet hits a wall,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab if bullet.wallinteraction == BOUNCE,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab bullet bounces off the wall;\lang1033\fs24\par
\lang9\fs22\tab\tab\tab else if == STOP,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab bullet stops;\lang1033\fs24\par
\lang9\fs22\tab\tab\tab else if == PIERCE,\lang1033\fs24\par
\lang9\fs22\tab\tab\tab\tab //do nothing\tab\lang1033\fs24\par
\lang9\fs22\tab\}\lang1033\f0\fs24\par
\lang9\f4\fs22\tab\lang1033\f0\fs24\par
\par
\par
\par
\lang9\f3\fs22\tab In the MapEditor, it will be a drag and drop style map creator\lang1033\f0 . Its update cycle \tab looks like this:\par
\tab\f2 /*MapEditor*/ update\par
\tab\{\par
\tab\tab update the MEEntityManager;\par
\tab\tab update the MenuManager;\par
\tab\}\par
\tab\f5\par
\tab Updating the MEEntityManager looks like this:\par
\tab\f2 /*MEEntityManager*/ update\par
\tab\{\par
\tab\tab drag and drop MEEntities;\par
\tab\tab based on the MEMap collision boxes, place walls and \tab\tab\tab spawnpoints;\par
\tab\}\par
\tab\f5 Finding out where to places dropped walls goes like this:\par
\tab\f2 findDropPlace\par
\tab\{\par
\tab\tab if wall is dropped,\par
\tab\tab\tab if cursor was inside a hitbox on a side of a \tab\tab\tab\tab square of the grid in MEMap,\par
\tab\tab\tab\tab add a wall there if it doesnt make a wall \tab\tab\tab\tab\tab ring, combine adjacent walls;\par
\tab\tab else if x is dropped,\par
\tab\tab\tab if cursor was inside a hitbox in he center of a \tab\tab\tab square of the grid in MEMap,\par
\tab\tab\tab\tab add x there;\par
\tab\}\par
\tab\f5 Checking wall rings is neccesarry. Imagine if a player created a map with two \tab spawnpoints sectioned completly off by walls. the tanks would never interact.\par
\tab\f2 FindWallRings\par
\tab\{\par
\tab\tab while there exists a wall with one non-connected end\par
\tab\tab\{\par
\tab\tab\tab remove  all walls that have one end not \tab\tab\tab\tab\tab connecting to anything\par
\tab\tab\}\par
\tab\tab if there are any non-edge walls left, there is a \tab\tab\tab ring.\par
\tab\}\par
\tab\f5 Combining adjacent walls goes like this:\par
\tab\f2 combineWalls\par
\tab\{\par
\tab\tab if the place the wall was just placed in has a \tab\tab\tab\tab neighbor spot with a wall, \par
\tab\tab\tab make a new wall with the max and min vertices of \tab\tab\tab the walls;\par
\par
\tab\}\par
\f0\fs24\par
\par
\par
\lang9\f3\fs22\tab\lang1033\f0\fs24\par
\lang9\b\fs22\tab\lang1033\b0\fs24\par
\pard\nowidctlpar\sa200\sl240\slmult1\lang9\b\f6\fs22\tab\lang1033\b0\f0\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
}
 